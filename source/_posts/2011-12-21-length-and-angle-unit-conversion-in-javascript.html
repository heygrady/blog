---
layout: post
title: "Length and Angle Unit Conversion in JavaScript"
date: 2011-12-21 10:18
comments: true
categories: css javascript
---
<p>When creating JavaScript libraries, it's difficult to support a range of units and most developers settle on just supporting pixels. CSS supports several <a href="https://developer.mozilla.org/en/CSS/length">units for length as explained is this MDN article</a> but supporting them with JavaScript can be tricky. This article explains a few different techniques and walks through a new <a href="https://github.com/heygrady/Units">Units library I've created on GitHub</a>.</p>
<!--more-->
{% h2 The Trouble with Units %}
<p>Converting between length units is particularly difficult because all of the units means something different based on factors such as font and font-size (em, ch, ex), the operating system settings for your monitor (in, cm, mm, pt) or even the dimensions of the browser (vh, vw, vm). Because there is no direct conversion it's necessary to rely on manipulating the style attribute on the element to trick the browser into doing the conversion for you.</p>
{% h3 Absolute Length Units %}
<p>The easiest units to convert are the absolute units. These are units that presumably represent real, fixed lengths. In the the real world there is no such thing as a relative inch &mdash; an inch is always an inch. On computers it's a little different; the absolute lengths are based on the operating system <abbr title="Dots Per Inch">DPI</abbr> setting. On the vast majority of computers this is set to 96, which means that 1 inch equals 96 pixels. However, this can sometimes change; it's not entirely uncommon for the DPI to be set to 120 which would make 1 inch equal 120 pixels.</p>
<p>All of the other conversions are really simple as they can be converted relative to the inch. Thankfully a pixel is always a pixel. Because DPI is the deciding factor in absolute lengths, it's useful to define the conversions relative to the inch.</p>
<dl>
	<dt>inches</dt>
	<dd>relative to OS DPI, usually 96px</dd>
	<dt>millimeters</dt>
	<dd>1mm = 1in/25.4</dd>
	<dt>centimeters</dt>
	<dd>1cm = 1in/2.54</dd>
	<dt>point</dt>
	<dd>1pt = 1in/72</dd>
	<dt>picas</dt>
	<dd>1pc = 1in/6</dd>
</dl>
{% h3 Font-relative Length Units %}
<p>As the name might suggest, font-relative units are dependent on the font and font-size of the element. The most commonly used is the em unit. One em equals the font-size of the element (except in the case of the font-size property where it means the font-size of the parent element). The ex and ch units are rarely used and equal the hight of lower-case "x" and the width of a "0" respectively. New to CSS3, and much more useful than ex, is the rem unit which equals the em of the html element. Converting rem and em to pixels is relatively straight-forward &mdash; all you really need is the element's (or the html element's) font-size &mdash; but ex and ch require using the style attribute as we'll see later.</p>
{% h3 Viewport-relative Length Units %}
<p>Presumably useful for flexible layouts, these units are relative to the browser size and are currently only supported in IE9. The three units are vh (viewport height/100) vw (viewport width/100) and vm, the smaller of vh or vw. These units change every time the browser is resized.</p>
{% h3 Percentage Lengths %}
<p>Perhaps the most complex unit to convert is percentage. The relative length for a percentage is different for absolutely every CSS property but it is usually based on the parent element. For instance, a width of 50% means 50% of the width of the parent element. For thing like padding and margin it can get confusing because these also always mean the width of the parent; counter-intuitively, padding-top of 50% means 50% of the width of the parent element. The best way to figure out what percentage is referring to is to <a href="https://developer.mozilla.org/en/CSS/padding">look the property up on the MDN website</a>.</p>
{% h2 Converting Units %}
<p>As mentioned above, converting units can be done reliably by setting the value using the style property and reading it back as the computed value. Browsers always report CSS units in pixels to simplify things.</p>
{% codeblock Converting units with the style property lang:js %}
(function(document, undefined){
"use strict";
// convert a value to pixels
function toPx(elem, value, prop) {
    prop = prop || 'width';
    var style = elem.style[prop],
        val;
    
    // set the style on the target element
    try {
   		elem.style[prop] = value; // IE crashes on un
    } catch(e) {
    	return 0;
    }

    // read the current value
    val = currCSS(elem, prop);

    // reset the style back to what it was or blank it out
    elem.style[prop] = style || null;

    return parseFloat(val);
}

// return the computed value of a CSS property
function currCSS(elem, prop) {
    var value,
        pixel = elem.style['pixel' + prop.charAt(0).toUpperCase() + prop.slice(1)],
        getComputedStyle = document.defaultView && document.defaultView.getComputedStyle,
        unit;
    if (pixel) {
        // IE and Opera support pixel shortcuts for top, bottom, left, right, height, width
        value = pixel + 'px';
    } else if (getComputedStyle) {
        // FireFox, Chrome/Safari, Opera and IE9+
        value = getComputedStyle(elem)[prop];
    } else {
        // IE 8 and below won't convert units for us
        value = elem.currentStyle[prop];

        // check the unit
        unit = (value.match(/^(-?[\d+\.\-]+)([a-z]+|%)$/i)||[])[2];
        if (unit && unit !== 'px') {
            // try to convert using a prop that will return pixels
            // this will be accurate for everthing (except percentages in some cases)
            value = toPx(elem, value, 'width') + 'px';
        }
    }
    return value;
}

// explose the conversion function to the window object
window.Length = {
    toPx: toPx
}
}(this.document));
{% endcodeblock %}
<p>The code above is the bare minimum necessary to convert pixel units but it has a few problems. First, lets look at what we're doing in the code. In the the toPx function, we can convert any unit by assigning the value to the elements style, reading that value using getComputedStyle using the currCSS function and then changing the element's style back. IE 8 and below use currentStyle instead of getComputedStyle and it works slightly differently. Specifically, currentStyle won't convert an absolute length to pixels. For instance, if the fontSize is 10mm, IE8 and below will return it as 10mm. Thankfully IE has built in a few non-standard properties that always return pixel values. The most commonly used property is <a href="http://msdn.microsoft.com/en-us/library/ms531129(v=VS.85).aspx">pixelLeft</a>, however <a href="http://msdn.microsoft.com/en-us/library/ms531135(v=VS.85).aspx">pixelWidth</a> and pixelHeight work just as well. In the example above the default property is set to width because in non-IE browsers left cannot be set on a position: static element.</p>
{% h3 Problems with this Method %}
<p>The first problem is that our code is needlessly setting setting styles on the element itself for each check being made. For absolute units this isn't strictly necessary. Those conversion values can be calculated when the page is loaded and used repeatedly. Secondly, converting for em only requires knowing the computed font-size for the element of its parent, again, there's no reason to set anything on the element's style. Lastly, setting the style on an element can have adverse consequences like a flash of unstyled content or might throw an error. In IE 8 and below, unrecognized units will result in an error. In non-IE browsers, the actual computed width is returned for unrecognized units instead of 0 as might be expected.</p>
{% h3 Returning Absolute Units Faster %}
<p>The code below pre-calculates absolute units by setting them on a test element when the script is first run, the conversions are then stored and re-used later. This avoids the need to set the element style and look up the computed style. There's still problems with percentage units for height and width when the element is diaplay: inline.</p>
{% codeblock Returning Absolute Units Faster lang:js %}
// create an element to test with
var testElem = document.createElement('test'),
    convert = {},
    units = ['mm', 'cm', 'pt', 'pc', 'in', 'mozmm'],
    conversions = [1/25.4, 1/2.54, 1/72, 1/6],
    i = units.length,
    runit = /^(-?[\d+\.\-]+)([a-z]+|%)$/i,
    docElement = document.documentElement;

// add our element to the DOM
docElement.appendChild(testElem);

// make sure our element is position absolute
testElem.style.position = 'absolute';

// loop our absolute units
while(i--) {
    convert[units[i] + 'ToPx'] = conversions[i] ? conversions[i] * convert.inToPx : toPx(testElem, '1' + units[i]);
}

// yank the test element out of the dom
docElement.removeChild(testElem);

// convert a value to pixels
function toPx(elem, value, prop) {
    prop = prop || 'width';
    var style,
        val,
        unit = value.match(runit)[2];
    
    // return known conversions immediately
    if (convert[unit + 'ToPx']) {
        val = parseFloat(value) * convert[unit + 'ToPx'];
    } else {
        // capture the current value
        style = elem.style[prop];
        
        // set the style on the target element
        try {
            elem.style[prop] = value;
        } catch(e) {
            return 0;
        }

        // read the current value
        val = parseFloat(currCSS(elem, prop));

        // reset the style back to what it was or blank it out
        elem.style[prop] = style || null;
    }

    return val;
}
//... see code above
{% endcodeblock %}

{% h3 Making Better Use of the Test Element %}
<p>Since we've got a test element, there's no reason not to simply run all conversions on the test element to avoid an collisions on our element itself.</p>

{% codeblock Returning Absolute Units Faster lang:js %}
{% endcodeblock %}